## 커넥션 풀

## datasource
### 배경
* A 커넥션 풀을 사용하다가 B 커넥션 풀을 사용하게 되면 애플리케이션 코드도 변경되어야 한다.

* 그래서 datasource 가 새롭게 나옴.
* 커넥션을 획득하는 방법을 추상화.

```java
public interface DataSource {
    Connection getConnection() throws SQLException;
}
```

* 개발자는 DataSource에 의존 => 커넥션 풀 구현 기술을 변경하고 싶으면 구현체만 교체
* 하지만 Drivermanager는 DataSource 인터페이스에 의존하지 않음
* DriverManager 도 DataSource 를 통해서 사용할 수 있도록 DriverManagerDataSource 라는 DataSource 를 구현한 클래스를 제공

## 트랜잭션
* 커넥션을 하면 db 내부적으로 세션이 생김

* 성공하면 커밋
* 실패하면 롤백

* 스프링이 제공하는 트랜잭션 추상화 기술을 사용 (PlatformTransactionManager)
* 스프링이 제공하는 트랜잭션 동기화 기술을 사용
  * 트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 데이터베이스 커넥션을 유지
  * 트랜잭션 동기화 매니저를 제공한다. 이것은 쓰레드 로컬( ThreadLocal )을 사용해서 커넥션을 동기화해준다. 트랜잭션 매니저는 내부에서 이 트랜잭션 동기화 매니저를 사용

동작 방식
1. 커넥션을 만들고 트랜잭션을 시작
2. 커넥션을 트랜잭션 동기화 매니저에 보관
3. 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 따라서 파라미터로 커넥션을 전달하지 않아도 된다.
4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 닫는다.

## 예외 계층
### error
* 애플리케이션의 복구 불가능한 시스템 예외 - 예외를 잡으면 안됨
  * 애플리케이션에서 throwable 예외도 잡으면 안됨 - Error도 같이 잡힐 수 있음

### Exception
1. RuntimeException
   * 언체크 예외
     * 예외를 잡지 않으면 자동으로 밖으로 던짐
2. 그 외
   * 컴파일러가 체크하는 체크 예외
     * 예외를 잡아서 처리하거나 던지거나 무조건 해야함
     * try catch or throws 로 던지기

체크 예외 활용
* 런타임(언체크) 예외를 언제 사용할까?
* 기본원칙 두개
  * 기본적으로 언체크 예외 사용
  * 체크예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용 (중요한것들!!)
* 체크 예외의 문제점
  * connectException, SQLException 과같은 문제들은 애플리케이션에서 처리할 방법이 없음
  * 500코드, 오류 로그를 남기고 개발자가 처리해야함
  * 결국 할 수 있는게 없는데 모든 서비스, 컨트롤러 코드에서 의존해야한다.
* 런타임 예외
  * 의존관계에 대한 문제 해결
  * 대부분 복구 불가능한 예외 - 신경쓰지 않고 일관성 있게 공통 처리

* 예외를 전환할때는 꼭 기존 예외를 포함하자!
